START
Entree de Level
/////////////// DEBUT Objet
---- Nouveau champ : next
ALLOC 1
DUPN 1
PUSHI 1
STOREG 0
Entree de Level
(null)_incr: NOP
Integer_incr: NOP
Entree de Level
(null)_howMany: NOP
Integer_howMany: NOP
Sortie de Level
Sortie de Level
/////////////// FIN Objet
Sortie de Level
Entree de Level
---------- DEBUT Classe
PUSHI 0
PUSHI 0
PARAMDEF INTEGER
PUSHS 
PUSHS 
PARAMDEF STRING
Entree de Level
------DEBUT BLOC
PUSHN 1
PUSHA incr
CALL
POPN 2
------FIN BLOC
Sortie de Level
---------- DEBUT CorpsCLasse
---- Nouveau champ : hasClone
ALLOC 1
DUPN 1
PUSHI 0
STOREG 6
---- Nouveau champ : clone
ALLOC 1
DUPN 1
STOREG 8
Entree de Level
(null)_setName: NOP
Void_setName: NOP
Sortie de Level
---------- Fin CorpsClasse
---------- Fin Classe
Sortie de Level
Entree de Level
---------- DEBUT Classe
PUSHI 0
PUSHI 0
PARAMDEF INTEGER
Entree de Level
------DEBUT BLOC
PUSHN 1
PUSHI 0
PUSHA coul
CALL
POPN 2
JZ ELSE1
THEN0 : 	NOP
ALLOC 1
DUPN 1
PUSHI 0
JUMP ENDIFELSE2
ELSE1 : 	NOP
PUSHN 1
PUSHI 2
PUSHA coul
CALL
POPN 2
JZ ELSE4
THEN3 : 	NOP
ALLOC 1
DUPN 1
PUSHI 0
JUMP ENDIFELSE5
ELSE4 : 	NOP
Entree de Level
------DEBUT BLOC
------FIN BLOC
Sortie de Level
SORTIE IF/ELSE : 	NOP
SORTIE IF/ELSE : 	NOP
------FIN BLOC
Sortie de Level
---------- DEBUT CorpsCLasse
Entree de Level
(null)_name: NOP
Void_name: NOP
PUSHI 0
PUSHI 0
PARAMDEF INTEGER
Sortie de Level
---------- Fin CorpsClasse
---------- Fin Classe
Sortie de Level
Entree de Level
/////////////// DEBUT Objet
---- Nouveau champ : theBlanc
ALLOC 1
DUPN 1
---- Nouvelle Instanciation de type  : Couleur
ALLOC 1
DUPN 1
STOREG 21
---- Nouveau champ : theNoir
ALLOC 1
DUPN 1
---- Nouvelle Instanciation de type  : Couleur
ALLOC 1
DUPN 1
PUSHI 1
STOREG 24
---- Nouveau champ : theGris
ALLOC 1
DUPN 1
---- Nouvelle Instanciation de type  : Couleur
ALLOC 1
DUPN 1
PUSHI 2
STOREG 28
Entree de Level
(null)_blanc: NOP
Couleur_blanc: NOP
Entree de Level
(null)_noir: NOP
Couleur_noir: NOP
Entree de Level
(null)_gris: NOP
Couleur_gris: NOP
Sortie de Level
Sortie de Level
Sortie de Level
/////////////// FIN Objet
Sortie de Level
Entree de Level
---------- DEBUT Classe
PUSHI 0
PUSHI 0
PARAMDEF INTEGER
PUSHI 0
PUSHI 0
PARAMDEF INTEGER
PUSHN 1
PUSHA blanc
CALL
POPN 2
PUSHN 1
PUSHA blanc
CALL
POPN 2
---------- DEBUT CorpsCLasse
Entree de Level
(null)_couleur: NOP
Void_couleur: NOP
Sortie de Level
---------- Fin CorpsClasse
---------- Fin Classe
Sortie de Level
Entree de Level
---------- DEBUT Classe
---------- DEBUT CorpsCLasse
Entree de Level
(null)_estGris: NOP
Void_estGris: NOP
Sortie de Level
---------- Fin CorpsClasse
---------- Fin Classe
Sortie de Level
Entree de Level
---------- DEBUT Classe
---------- DEBUT CorpsCLasse
Entree de Level
(null)_estGris: NOP
Void_estGris: NOP
Sortie de Level
---------- Fin CorpsClasse
---------- Fin Classe
Sortie de Level
Entree de Level
/////////////// DEBUT Objet
Entree de Level
(null)_test: NOP
Void_test: NOP
Entree de Level
(null)_test2: NOP
Void_test2: NOP
Sortie de Level
Sortie de Level
/////////////// FIN Objet
Sortie de Level
Entree de Level
---------- DEBUT Classe
---------- DEBUT CorpsCLasse
---- Nouveau champ : v
ALLOC 1
DUPN 1
PUSHI 1
STOREG 36
Entree de Level
(null)_f: NOP
Void_f: NOP
Sortie de Level
---------- Fin CorpsClasse
---------- Fin Classe
Sortie de Level
Entree de Level
---------- DEBUT Classe
---------- DEBUT CorpsCLasse
---- Nouveau champ : v
ALLOC 1
DUPN 1
PUSHS "hello"; /* masque le champ v de la classe A */

  override def f() is { "A2::f()\"n".print(); }

  def g() is {
      v := "world"; /* par defaut, il s'agit du champ de A2 */
      /* this etant caste en A, le champ v en question est celui de A */
      (A this).v := 1;
      /* les deux appels doivent fournir la meme chose */
      this.f();
      (A this).f();
  }

  /* ajoute une valmeur par defaut Ã  x qui n'en avait pas. Le parametre
   * y conserve sa valeur par defaut definie dans la methode de la superclasse
   */
  /*override def h(x : Integer := 3, y: Integer) : Integer := super.h(x, y)*/
}

{ /* Bloc qui correspond au programme principal */
  var p1: Point := new Point(1, 5, "p1");
  var p2: Point := new Point(2, 3, "p2");
  var p3 : Point := new Point(); /* utilise toutes les valeurs par defaut */
  /* Incorrect: les types ne sont pas consideres quand on decide s'il faut
   * utiliser les valeurs par defaut. Si on donne un argument, ca doit
   * forcement correspondre au premier parametre, etc. Ci-dessous, on ne
   * peut pas omettre les coordonnees et ne passer que la couleur !
   * var err : PointColore := new PointColore(new Couleur(25));
   */
  var o : PointColore := new PointColore(0, 0, (new Couleur(0)).blanc());
  var pn : PointNoir := new PointNoir(+1, -1);
  /* Incorrect: le constructeur de PointNoir n'est pas une redefinition
   * du constructeur de PointColore ou de Point. Il ne beneficie donc
   * pas de valeurs par defaut pour ses arguments (masi on aurait pu en
   * prevoir dans sa definition)
   * var pn2 : PointNoir := new PointNoir();
   */
  var dp : DefaultPoint := new DefaultPoint();
is
  p2.move(p1.getx(), p1.gety());
  o.setName("origine");
  p2.move(p1.getx()-2*5-3, p1.gety());
  o.print();
  p2.print();
  o.clone().print();
  o.clone().move(54, 36).print(true);
  O.allClones();
  /* Ne doit pas compiler car clone() renvoie statiquement un Point alors
   * que o est declare com
STOREG 38
Entree de Level
(null)_f: NOP
Void_f: NOP
Sortie de Level
---------- Fin CorpsClasse
---------- Fin Classe
Sortie de Level
------------DEBUT Bloc Principal
Entree de Level
------DEBUT BLOC
---- Nouveau champ : p1
ALLOC 1
DUPN 1
---- Nouvelle Instanciation de type  : Point
ALLOC 1
DUPN 1
PUSHI 1
PUSHI 5
PUSHS "p1");
  var p2: Point := new Point(2, 3, "p2");
  var p3 : Point := new Point(); /* utilise toutes les valeurs par defaut */
  /* Incorrect: les types ne sont pas consideres quand on decide s'il faut
   * utiliser les valeurs par defaut. Si on donne un argument, ca doit
   * forcement correspondre au premier parametre, etc. Ci-dessous, on ne
   * peut pas omettre les coordonnees et ne passer que la couleur !
   * var err : PointColore := new PointColore(new Couleur(25));
   */
  var o : PointColore := new PointColore(0, 0, (new Couleur(0)).blanc());
  var pn : PointNoir := new PointNoir(+1, -1);
  /* Incorrect: le constructeur de PointNoir n'est pas une redefinition
   * du constructeur de PointColore ou de Point. Il ne beneficie donc
   * pas de valeurs par defaut pour ses arguments (masi on aurait pu en
   * prevoir dans sa definition)
   * var pn2 : PointNoir := new PointNoir();
   */
  var dp : DefaultPoint := new DefaultPoint();
is
  p2.move(p1.getx(), p1.gety());
  o.setName("origine");
  p2.move(p1.getx()-2*5-3, p1.gety());
  o.print();
  p2.print();
  o.clone().print();
  o.clone().move(54, 36).print(true);
  O.allClones();
  /* Ne doit pas compiler car clone() renvoie statiquement un Point alors
   * que o est declare com
STOREG 40
---- Nouveau champ : p2
ALLOC 1
DUPN 1
---- Nouvelle Instanciation de type  : Point
ALLOC 1
DUPN 1
PUSHI 2
PUSHI 3
PUSHS "p2");
  var p3 : Point := new Point(); /* utilise toutes les valeurs par defaut */
  /* Incorrect: les types ne sont pas consideres quand on decide s'il faut
   * utiliser les valeurs par defaut. Si on donne un argument, ca doit
   * forcement correspondre au premier parametre, etc. Ci-dessous, on ne
   * peut pas omettre les coordonnees et ne passer que la couleur !
   * var err : PointColore := new PointColore(new Couleur(25));
   */
  var o : PointColore := new PointColore(0, 0, (new Couleur(0)).blanc());
  var pn : PointNoir := new PointNoir(+1, -1);
  /* Incorrect: le constructeur de PointNoir n'est pas une redefinition
   * du constructeur de PointColore ou de Point. Il ne beneficie donc
   * pas de valeurs par defaut pour ses arguments (masi on aurait pu en
   * prevoir dans sa definition)
   * var pn2 : PointNoir := new PointNoir();
   */
  var dp : DefaultPoint := new DefaultPoint();
is
  p2.move(p1.getx(), p1.gety());
  o.setName("origine");
  p2.move(p1.getx()-2*5-3, p1.gety());
  o.print();
  p2.print();
  o.clone().print();
  o.clone().move(54, 36).print(true);
  O.allClones();
  /* Ne doit pas compiler car clone() renvoie statiquement un Point alors
   * que o est declare com
STOREG 46
---- Nouveau champ : p3
ALLOC 1
DUPN 1
---- Nouvelle Instanciation de type  : Point
ALLOC 1
DUPN 1
STOREG 52
---- Nouveau champ : o
ALLOC 1
DUPN 1
---- Nouvelle Instanciation de type  : PointColore
ALLOC 1
DUPN 1
PUSHI 0
PUSHI 0
PUSHN 1
PUSHA 
CALL
POPN 2
PUSHN 1
PUSHA blanc
CALL
POPN 2
STOREG 55
---- Nouveau champ : pn
ALLOC 1
DUPN 1
---- Nouvelle Instanciation de type  : PointNoir
ALLOC 1
DUPN 1
PUSHI 1
ADD
PUSHI 1
SUB
STOREG 60
---- Nouveau champ : dp
ALLOC 1
DUPN 1
---- Nouvelle Instanciation de type  : DefaultPoint
ALLOC 1
DUPN 1
STOREG 63
PUSHN 1
PUSHA p2
CALL
POPN 2
PUSHN 1
PUSHN 1
PUSHA p1
CALL
POPN 2
PUSHN 1
PUSHA getx
CALL
POPN 2
PUSHN 1
PUSHA p1
CALL
POPN 2
PUSHN 1
PUSHA gety
CALL
POPN 2
PUSHA move
CALL
POPN 2
PUSHN 1
PUSHA o
CALL
POPN 2
PUSHN 1
PUSHS "origine");
  p2.move(p1.getx()-2*5-3, p1.gety());
  o.print();
  p2.print();
  o.clone().print();
  o.clone().move(54, 36).print(true);
  O.allClones();
  /* Ne doit pas compiler car clone() renvoie statiquement un Point alors
   * que o est declare com
PUSHA setName
CALL
POPN 2
PUSHN 1
PUSHA p2
CALL
POPN 2
PUSHN 1
PUSHN 1
PUSHA p1
CALL
POPN 2
PUSHN 1
PUSHA getx
CALL
POPN 2
PUSHI 2
PUSHI 5
MUL
SUB
PUSHI 3
SUB
PUSHN 1
PUSHA p1
CALL
POPN 2
PUSHN 1
PUSHA gety
CALL
POPN 2
PUSHA move
CALL
POPN 2
PUSHN 1
PUSHA o
CALL
POPN 2
PUSHN 1
PUSHA print
CALL
POPN 2
PUSHN 1
PUSHA p2
CALL
POPN 2
PUSHN 1
PUSHA print
CALL
POPN 2
PUSHN 1
PUSHA o
CALL
POPN 2
PUSHN 1
PUSHA clone
CALL
POPN 2
PUSHN 1
PUSHA print
CALL
POPN 2
PUSHN 1
PUSHA o
CALL
POPN 2
PUSHN 1
PUSHA clone
CALL
POPN 2
PUSHN 1
PUSHI 54
PUSHI 36
PUSHA move
CALL
POPN 2
PUSHN 1
PUSHA print
CALL
POPN 2
PUSHN 1
PUSHA allClones
CALL
POPN 2
ALLOC 1
DUPN 1
PUSHN 1
PUSHA p1
CALL
POPN 2
PUSHN 1
PUSHA clone
CALL
POPN 2
PUSHN 1
PUSHI 2
ADD
PUSHI 3
SUB
PUSHA move
CALL
POPN 2
PUSHN 1
PUSHA p1
CALL
POPN 2
PUSHN 1
PUSHA print
CALL
POPN 2
PUSHN 1
PUSHA o
CALL
POPN 2
PUSHN 1
PUSHA clone
CALL
POPN 2
PUSHN 1
PUSHA print
CALL
POPN 2
PUSHN 1
PUSHA "test(Point, PointColore, PointNoir)".println();
  unTest.test(p1, o, pn);
  "test(PointNoir, PointNoir, PointNoir)".println();
  unTest.test(pn, pn, pn);
  p1 := pn; /* affectation entre pointeurs ! */
  unTest.test2(o);
  unTest.test2(pn);
  o := pn;  /* Idem : on doit avoir de la liaison dynamique ci-dessous */

  "test(PointNoir, PointNoir, PointNoir)".println();
  unTest.test(p1, o, pn);
  unTest.test2(o);
  unTest.test2(pn);
  "\nDone".println();
}
CALL
POPN 2
PUSHN 1
PUSHA println
CALL
POPN 2
PUSHN 1
PUSHA unTest
CALL
POPN 2
PUSHN 1
PUSHA test
CALL
POPN 2
PUSHN 1
PUSHA "test(PointNoir, PointNoir, PointNoir)".println();
  unTest.test(pn, pn, pn);
  p1 := pn; /* affectation entre pointeurs ! */
  unTest.test2(o);
  unTest.test2(pn);
  o := pn;  /* Idem : on doit avoir de la liaison dynamique ci-dessous */

  "test(PointNoir, PointNoir, PointNoir)".println();
  unTest.test(p1, o, pn);
  unTest.test2(o);
  unTest.test2(pn);
  "\nDone".println();
}
CALL
POPN 2
PUSHN 1
PUSHA println
CALL
POPN 2
PUSHN 1
PUSHA unTest
CALL
POPN 2
PUSHN 1
PUSHA test
CALL
POPN 2
ALLOC 1
DUPN 1
PUSHN 1
PUSHA unTest
CALL
POPN 2
PUSHN 1
PUSHA test2
CALL
POPN 2
PUSHN 1
PUSHA unTest
CALL
POPN 2
PUSHN 1
PUSHA test2
CALL
POPN 2
ALLOC 1
DUPN 1
PUSHN 1
PUSHA "test(PointNoir, PointNoir, PointNoir)".println();
  unTest.test(p1, o, pn);
  unTest.test2(o);
  unTest.test2(pn);
  "\nDone".println();
}
CALL
POPN 2
PUSHN 1
PUSHA println
CALL
POPN 2
PUSHN 1
PUSHA unTest
CALL
POPN 2
PUSHN 1
PUSHA test
CALL
POPN 2
PUSHN 1
PUSHA unTest
CALL
POPN 2
PUSHN 1
PUSHA test2
CALL
POPN 2
PUSHN 1
PUSHA unTest
CALL
POPN 2
PUSHN 1
PUSHA test2
CALL
POPN 2
PUSHN 1
PUSHA "\nDone".println();
}
CALL
POPN 2
PUSHN 1
PUSHA println
CALL
POPN 2
------FIN BLOC
Sortie de Level
------------FIN Bloc Principal

