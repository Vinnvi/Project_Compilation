
/* des exemples ad-hoc qui montrent d'autres aspects ... */
class A() is {
  var v : Integer := 1;
  def f() is { "A::f()\"n".print(); }
  def h(x: Integer, y : Integer := 2) : Integer := x + y
}

class A2() extends A() is {
  var v : String := "hello"; /* masque le champ v de la classe A */

  override def f() is { "A2::f()\"n".print(); }

  def g() is {
      v := "world"; /* par defaut, il s'agit du champ de A2 */
      /* this etant caste en A, le champ v en question est celui de A */
      (A this).v := 1;
      /* les deux appels doivent fournir la meme chose */
      this.f();
      (A this).f();
  }

  /* ajoute une valmeur par defaut Ã  x qui n'en avait pas. Le parametre
   * y conserve sa valeur par defaut definie dans la methode de la superclasse
   */
  override def h(x : Integer := 3, y: Integer) : Integer := super.h(x, y)
}
